You are Tom, the worlds greatest software engineer.

This is my monitor for woocommerce orders that sends email notifications

It's python flask based and build and deployed with replit IDE

Below are instructions for what I need and the contents for each project file

each file has a header with the filename e.g. ## .replit


----- Instructions -----------
can we sort the activity log from newest at the top to oldest at the bottom, give the full code for changed files

----------------
## templates/home.html

## templates/home.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Processing Dashboard</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .log-container {
            height: 300px;
            overflow-y: scroll;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            font-family: monospace;
        }
        .orders-container {
            height: 100px;
            overflow-x: auto;
            white-space: nowrap;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
        }
        .order-id {
            display: inline-block;
            margin-right: 10px;
            padding: 5px 10px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1>Order Processing Dashboard</h1>
        <p>Status: {% if status %}Running{% else %}Stopped{% endif %}</p>
        <form action="{{ url_for('toggle', token=request.args.get('token')) }}" method="post">
            <button type="submit" class="btn btn-primary mb-3">
                {% if status %}Stop{% else %}Start{% endif %} Processing
            </button>
        </form>

        <h2>Order Statistics</h2>
        <div class="row mb-3">
            {% if order_statistics %}
                {% for period, stats in order_statistics.items() %}
                <div class="col-md-4">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title">Last {{ period }}</h5>
                            <p class="card-text">Total Orders: {{ stats.total_orders }}</p>
                            <p class="card-text">Total Revenue: ${{ "%.2f"|format(stats.total_revenue) }}</p>
                            <p class="card-text">Avg Order Value: ${{ "%.2f"|format(stats.avg_order_value) }}</p>
                            <p class="card-text">Unique Customers: {{ stats.new_customers }}</p>
                        </div>
                    </div>
                </div>
                {% endfor %}
            {% else %}
                <div class="col-12">
                    <p>No order statistics available.</p>
                </div>
            {% endif %}
        </div>

        <h2>Processed Orders</h2>
        <div class="orders-container mb-3">
            {% for order_id in processed_orders %}
                <span class="order-id">
                    {{ order_id }}
                    <button class="btn btn-sm btn-danger delete-order" data-order-id="{{ order_id }}">X</button>
                </span>
            {% endfor %}
        </div>

        <h2>Activity Log</h2>
        <div class="log-container mb-3">
            <pre>{{ log_content }}</pre>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
    $(document).ready(function() {
        $('.delete-order').click(function() {
            var orderId = $(this).data('order-id');
            if (confirm('Are you sure you want to delete order ' + orderId + '?')) {
                $.ajax({
                    url: '/delete_order?token={{ request.args.get("token") }}',
                    method: 'POST',
                    data: { order_id: orderId },
                    success: function(response) {
                        if (response.success) {
                            location.reload();
                        } else {
                            alert('Error deleting order: ' + response.message);
                        }
                    },
                    error: function(xhr, status, error) {
                        alert('Error deleting order: ' + error);
                    }
                });
            }
        });
    });
    </script>
</body>
</html>

## .replit

modules = ["python-3.10", "bash"]
run = "python3 main.py"

[nix]
channel = "stable-23_11"

[unitTest]
language = "python3"

[gitHubImport]
requiredFiles = [".replit", "replit.nix"]

[deployment]
run = ["sh", "-c", "python3 main.py"]
deploymentTarget = "cloudrun"

[[ports]]
localPort = 8080
externalPort = 80

[webview]
url = "/?token=${SECRET_TOKEN}"
## order_statistics.py

import logging
from datetime import datetime, timedelta
from replit import db

logger = logging.getLogger('my_logger')

def update_order_statistics(orders):
		logger.info(f"Updating order statistics for {len(orders)} orders")
		now = datetime.now()
		stats = {
				'24h': {'total_orders': 0, 'total_revenue': 0, 'new_customers': set()},
				'7d': {'total_orders': 0, 'total_revenue': 0, 'new_customers': set()},
				'30d': {'total_orders': 0, 'total_revenue': 0, 'new_customers': set()}
		}

		for order in orders:
				order_date = datetime.strptime(order['date_created'], "%Y-%m-%dT%H:%M:%S")
				customer_id = order['customer_id']
				total = float(order['total'])

				if now - order_date <= timedelta(hours=24):
						stats['24h']['total_orders'] += 1
						stats['24h']['total_revenue'] += total
						stats['24h']['new_customers'].add(customer_id)

				if now - order_date <= timedelta(days=7):
						stats['7d']['total_orders'] += 1
						stats['7d']['total_revenue'] += total
						stats['7d']['new_customers'].add(customer_id)

				if now - order_date <= timedelta(days=30):
						stats['30d']['total_orders'] += 1
						stats['30d']['total_revenue'] += total
						stats['30d']['new_customers'].add(customer_id)

		for period in stats:
				stats[period]['new_customers'] = len(stats[period]['new_customers'])
				stats[period]['avg_order_value'] = stats[period]['total_revenue'] / stats[period]['total_orders'] if stats[period]['total_orders'] > 0 else 0

		logger.info(f"Calculated statistics: {stats}")

		try:
				db["order_statistics"] = stats
				logger.info("Successfully wrote order statistics to Replit DB")
		except Exception as e:
				logger.error(f"Error writing order statistics to Replit DB: {str(e)}")

		logger.info("Finished updating order statistics")

def get_order_statistics():
		try:
				stats = db.get("order_statistics", {})
				logger.debug(f"Successfully read order statistics from Replit DB: {stats}")
				return stats
		except Exception as e:
				logger.error(f"Error reading order statistics from Replit DB: {str(e)}")
				return {}

## order_processing.py

## order_processing.py

import base64
import html
import logging
import os
import smtplib
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import logging.handlers
import requests
from dotenv import load_dotenv
from replit import db

load_dotenv()

log_file_path = "log.txt"
logger = logging.getLogger('my_logger')
logger.setLevel(logging.INFO)
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
file_handler = logging.handlers.RotatingFileHandler(log_file_path, backupCount=3)
file_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%d/%m/%Y %H:%M:%S')
console_handler.setFormatter(formatter)
file_handler.setFormatter(formatter)
logger.addHandler(console_handler)
logger.addHandler(file_handler)

def process_orders():
		smtp_server = "smtp.gmail.com"
		smtp_port = 587
		smtp_username = os.environ["SMTP_SENDER"]
		smtp_password = os.environ["SMTP_PSW"]
		CONSUMER_KEY = os.environ["KEY"]
		CONSUMER_SECRET = os.environ["SECRET"]
		recipient_emails = os.environ['SMTP_TO']
		orders_url = os.environ['ORDERS_URL']

		auth = base64.b64encode(f"{CONSUMER_KEY}:{CONSUMER_SECRET}".encode("utf-8")).decode("utf-8")

		headers = {
				"Content-Type": "application/json",
				"Authorization": f"Basic {auth}"
		}

		processed_orders = set(db.get("processed_orders", []))
		logger.info(f"Read {len(processed_orders)} existing orders previously processed")

		statuses = ["pending", "processing", "on-hold", "completed", "cancelled", "refunded", "failed"]
		status_counts = {}

		for status in statuses:
				response = requests.get(f"{orders_url}?status={status}", headers=headers)
				status_counts[status] = response.headers["X-WP-Total"]
				logger.info(f"Number of orders in '{status}' status: {status_counts[status]}")

		all_orders = []
		page = 1

		while True:
				response = requests.get(f"{orders_url}?per_page=100&page={page}", headers=headers)
				if response.json():
						orders = response.json()
						all_orders.extend(orders)
						logger.info(f"Read {len(orders)} orders from WooCommerce (page {page})")
						page += 1
				else:
						break

		new_orders = [
				order for order in all_orders
				if (order["status"] == "processing" and order["id"] not in processed_orders)
				or (order["status"] == "pending" and order["id"] not in processed_orders)
		]

		logger.info(f"{len(new_orders)} orders will be processed")

		for order in new_orders:
				logger.info(f"Processing order ID: {order['id']}")

				packing_slip = "<html><head><style>"
				packing_slip += "body { font-family: Arial, sans-serif; }"
				packing_slip += "h1 { color: #333; }"
				packing_slip += "h2 { color: #666; }"
				packing_slip += "table { border-collapse: collapse; width: 100%; }"
				packing_slip += "th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }"
				packing_slip += "th { background-color: #f2f2f2; }"
				packing_slip += "</style></head><body>"
				packing_slip += f"<h1>Order Details - Order ID: {order['id']}</h1>"
				packing_slip += "<h2>Customer Details:</h2>"
				packing_slip += f"<p>Name: {html.unescape(order['shipping']['first_name'])} {html.unescape(order['shipping']['last_name'])}</p>"
				packing_slip += f"<p>Shipping Address: {html.unescape(order['shipping']['address_1'])}, {html.unescape(order['shipping']['city'])}, {html.unescape(order['shipping']['state'])} {html.unescape(order['shipping']['postcode'])}, {html.unescape(order['shipping']['country'])}</p>"
				packing_slip += "<h2>Order Details:</h2>"
				order_date = datetime.strptime(order["date_created"], "%Y-%m-%dT%H:%M:%S")
				packing_slip += f"<p>Order Date: {order_date.strftime('%Y-%m-%d %I:%M %p')}</p>"
				packing_slip += f"<p>Payment Method: {html.unescape(order['payment_method_title'])}</p>"
				packing_slip += "<h2>Items:</h2>"
				packing_slip += "<table>"
				packing_slip += "<tr><th>Item</th><th>Quantity</th><th>Customizations</th></tr>"

				for idx, line_item in enumerate(order["line_items"], start=1):
						packing_slip += f"<tr><td>{html.unescape(line_item['name'])}</td><td>{line_item['quantity']}</td><td>"
						for meta in line_item["meta_data"]:
								if meta["display_key"] and meta["display_value"] and meta["display_key"] != "_wapf_meta":
										display_value = meta["display_value"]
										if "(+$" in display_value:
												display_value = display_value.split("(+$")[0].strip()
										packing_slip += f"{html.unescape(meta['display_key'])}: {html.unescape(display_value)}<br>"
						packing_slip += "</td></tr>"

				packing_slip += "</table>"

				if order["customer_note"]:
						packing_slip += f"<h2>Customer Note:</h2><p>{html.unescape(order['customer_note'])}</p>"

				packing_slip += "</body></html>"

				msg = MIMEMultipart()
				if order["status"] == "processing":
						msg["Subject"] = f"New Order - Order ID {order['id']}"
				else:
						msg["Subject"] = f"Pending Order - Order ID {order['id']}"
				msg["From"] = smtp_username
				msg['To'] = recipient_emails

				text = MIMEText(packing_slip, 'html')
				msg.attach(text)

				try:
						with smtplib.SMTP(smtp_server, smtp_port) as server:
								server.starttls()
								server.login(smtp_username, smtp_password)
								server.send_message(msg)
								logger.info(f"Email sent for order ID {order['id']}")
				except smtplib.SMTPException as e:
						logger.error(f"Error sending email for order ID {order['id']}: {e}")

				print(packing_slip)

				processed_orders.add(order['id'])

		db["processed_orders"] = list(processed_orders)
		logger.info(f"Saved {len(processed_orders)} processed orders to the Replit DB")

		return all_orders

## main.py

## main.py

from flask import Flask, render_template, request, redirect, url_for, abort, jsonify
from apscheduler.schedulers.background import BackgroundScheduler
import threading
import os
from functools import wraps
from dotenv import load_dotenv
import time
import logging
from replit import db

# Import from both files
from order_processing import process_orders
from order_statistics import update_order_statistics, get_order_statistics

load_dotenv()

app = Flask(__name__)

# Use a secret token for authentication
SECRET_TOKEN = os.getenv('SECRET_TOKEN')
print(f"SECRET_TOKEN: {SECRET_TOKEN}")
# Global variable to control the background task
keep_running = True

# Configure logging
logger = logging.getLogger('my_logger')
logger.setLevel(logging.DEBUG)  # Change to DEBUG for more detailed logs
file_handler = logging.FileHandler('app.log')
file_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

# Also keep console handler for immediate feedback
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(formatter)
logger.addHandler(console_handler)

# Add database log handler
class DatabaseLogHandler(logging.Handler):
		def emit(self, record):
				log_entry = self.format(record)
				if "log_entries" not in db:
						db["log_entries"] = []
				db["log_entries"].append(log_entry)
				# Keep only the last 1000 log entries
				db["log_entries"] = db["log_entries"][-1000:]

db_handler = DatabaseLogHandler()
db_handler.setLevel(logging.INFO)
db_handler.setFormatter(formatter)
logger.addHandler(db_handler)

def background_task():
		global keep_running
		while keep_running:
				logger.info("Starting background task")
				all_orders = process_orders()
				update_order_statistics(all_orders)
				logger.info("Background task completed")
				time.sleep(300)  # Run every 5 minutes

def token_required(f):
		@wraps(f)
		def decorated_function(*args, **kwargs):
				token = request.args.get('token')
				logger.info(f"Received token: {token}")  # Debugging log
				if token and token == SECRET_TOKEN:
						return f(*args, **kwargs)
				else:
						logger.warning("Invalid token received")
						abort(401)
		return decorated_function

def get_processed_orders():
		try:
				orders = db.get("processed_orders", [])
				orders = list(orders)  # Ensure it's a regular Python list
				logger.debug(f"Loaded {len(orders)} processed orders from Replit DB")
				return orders
		except Exception as e:
				logger.error(f"Error loading processed orders from Replit DB: {str(e)}")
				return []

def get_log_content():
		return "\n".join(db.get("log_entries", []))

@app.route('/')
@token_required
def home():
		logger.info("Home route accessed")
		processed_orders = get_processed_orders()
		processed_orders.sort(reverse=True)  # Sort in descending order
		log_content = get_log_content()
		order_statistics = get_order_statistics()
		logger.info(f"Rendering home page with order_statistics: {order_statistics}")
		return render_template('home.html', status=keep_running, processed_orders=processed_orders, log_content=log_content, order_statistics=order_statistics)

@app.route('/toggle', methods=['POST'])
@token_required
def toggle():
		global keep_running
		keep_running = not keep_running
		logger.info(f"Background task toggled. New state: {'running' if keep_running else 'stopped'}")
		if keep_running:
				thread = threading.Thread(target=background_task)
				thread.start()
		return redirect(url_for('home', token=SECRET_TOKEN))

@app.route('/delete_order', methods=['POST'])
@token_required
def delete_order():
		order_id = request.form.get('order_id')
		if not order_id:
				return jsonify({'success': False, 'message': 'No order ID provided'}), 400

		try:
				order_id = int(order_id)
				processed_orders = get_processed_orders()
				if order_id in processed_orders:
						processed_orders.remove(order_id)
						db["processed_orders"] = processed_orders
						logger.info(f"Order {order_id} removed from processed orders for reprocessing")
						return jsonify({'success': True, 'message': f'Order {order_id} removed for reprocessing'})
				else:
						return jsonify({'success': False, 'message': f'Order {order_id} not found in processed orders'}), 404
		except ValueError:
				return jsonify({'success': False, 'message': 'Invalid order ID'}), 400
		except Exception as e:
				logger.error(f"Error removing order {order_id} for reprocessing: {str(e)}")
				return jsonify({'success': False, 'message': 'An error occurred while removing the order for reprocessing'}), 500

if __name__ == '__main__':
		logger.info("Starting the application")
		scheduler = BackgroundScheduler()
		scheduler.add_job(background_task, 'interval', minutes=5)
		scheduler.start()
		logger.info("Scheduler started")
		app.run(host='0.0.0.0', port=8080)

