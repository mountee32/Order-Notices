You are Tom, the worlds greatest software engineer.

This is my monitor for woocommerce orders that sends email notifications

It's python flask based and build and deployed with replit IDE

Below are instructions for what I need and the contents for each project file

each file has a header with the filename e.g. ## .replit


----- Instructions -----------
how can i read/write the processed orders to a persistant replit database storage instead of a local json file?

----------------
## processed_orders.json

[7680, 7681, 7682, 7683, 7684, 7685, 7686, 7687, 7688, 7689, 7690, 7691, 7692, 7693, 7694, 7182, 7696, 7697, 7698, 7699, 7700, 7701, 7702, 7184, 7704, 7705, 7706, 7707, 7708, 7709, 7710, 7711, 7712, 7713, 7714, 7715, 7716, 7717, 7718, 7207, 7202, 7721, 7722, 7723, 7725, 7728, 7729, 7731, 7219, 7733, 7734, 7737, 7738, 7739, 7740, 7741, 7234, 7759, 7760, 7761, 7762, 7763, 7764, 7765, 7766, 7767, 7768, 7253, 7252, 7771, 7772, 7775, 7776, 7271, 7273, 7275, 7276, 7278, 7282, 7288, 7289, 7290, 7291, 7250, 7251, 7325, 7326, 7327, 7341, 7342, 7404, 7405, 7406, 7407, 7449, 7464, 7192, 7520, 7523, 7194, 7528, 7531, 7200, 7558, 7559, 7201, 7562, 7569, 7571, 7646, 7647, 7650, 7651, 7652, 7653, 7657, 7658, 7659, 7660, 7661, 7663, 7664, 7665, 7667, 7668, 7669, 7670, 7671, 7672, 7673, 7675, 7676, 7679]
## pending_orders.json

[]
## templates/home.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Processing Dashboard</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .log-container {
            height: 300px;
            overflow-y: scroll;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            font-family: monospace;
        }
        .orders-container {
            height: 100px;
            overflow-x: auto;
            white-space: nowrap;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
        }
        .order-id {
            display: inline-block;
            margin-right: 10px;
            padding: 5px 10px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1>Order Processing Dashboard</h1>
        <p>Status: {% if status %}Running{% else %}Stopped{% endif %}</p>
        <form action="{{ url_for('toggle', token=request.args.get('token')) }}" method="post">
            <button type="submit" class="btn btn-primary mb-3">
                {% if status %}Stop{% else %}Start{% endif %} Processing
            </button>
        </form>

        <h2>Order Statistics</h2>
        <div class="row mb-3">
            {% if order_statistics %}
                {% for period, stats in order_statistics.items() %}
                <div class="col-md-4">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title">Last {{ period }}</h5>
                            <p class="card-text">Total Orders: {{ stats.total_orders }}</p>
                            <p class="card-text">Total Revenue: ${{ "%.2f"|format(stats.total_revenue) }}</p>
                            <p class="card-text">Avg Order Value: ${{ "%.2f"|format(stats.avg_order_value) }}</p>
                            <p class="card-text">New Customers: {{ stats.new_customers }}</p>
                        </div>
                    </div>
                </div>
                {% endfor %}
            {% else %}
                <div class="col-12">
                    <p>No order statistics available.</p>
                </div>
            {% endif %}
        </div>

        <h2>Processed Orders</h2>
        <div class="orders-container mb-3">
            {% for order_id in processed_orders %}
                <span class="order-id">{{ order_id }}</span>
            {% endfor %}
        </div>

        <h2>Activity Log</h2>
        <div class="log-container mb-3">
            <pre>{{ log_content }}</pre>
        </div>
    </div>
</body>
</html>
## .replit

modules = ["python-3.10", "bash"]
run = "python3 main.py"

[nix]
channel = "stable-23_11"

[unitTest]
language = "python3"

[gitHubImport]
requiredFiles = [".replit", "replit.nix"]

[deployment]
run = ["sh", "-c", "python3 main.py"]
deploymentTarget = "cloudrun"

[[ports]]
localPort = 8080
externalPort = 80

[webview]
url = "/?token=${SECRET_TOKEN}"
## order_processing.py

import base64
import html
import json
import logging
import os
import smtplib
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import logging.handlers
import requests
from dotenv import load_dotenv

load_dotenv()

log_file_path = "log.txt"
logger = logging.getLogger('my_logger')
logger.setLevel(logging.INFO)
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
file_handler = logging.handlers.RotatingFileHandler(log_file_path, backupCount=3)
file_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%d/%m/%Y %H:%M:%S')
console_handler.setFormatter(formatter)
file_handler.setFormatter(formatter)
logger.addHandler(console_handler)
logger.addHandler(file_handler)

def process_orders():
		smtp_server = "smtp.gmail.com"
		smtp_port = 587
		smtp_username = os.environ["SMTP_SENDER"]
		smtp_password = os.environ["SMTP_PSW"]
		CONSUMER_KEY = os.environ["KEY"]
		CONSUMER_SECRET = os.environ["SECRET"]
		recipient_emails = os.environ['SMTP_TO']
		orders_url = os.environ['ORDERS_URL']

		auth = base64.b64encode(f"{CONSUMER_KEY}:{CONSUMER_SECRET}".encode("utf-8")).decode("utf-8")

		headers = {
				"Content-Type": "application/json",
				"Authorization": f"Basic {auth}"
		}

		processed_orders_file = "processed_orders.json"
		pending_orders_file = "pending_orders.json"

		try:
				with open(processed_orders_file, "r") as f:
						processed_orders = set(json.load(f))
						logger.info(f"Read {len(processed_orders)} existing orders previously processed")
		except FileNotFoundError:
				processed_orders = set()
				logger.info("No existing processed orders found")

		try:
				with open(pending_orders_file, "r") as f:
						pending_orders = set(json.load(f))
						logger.info(f"Read {len(pending_orders)} existing orders previously marked as pending")
		except FileNotFoundError:
				pending_orders = set()
				logger.info("No existing pending orders found")

		statuses = ["pending", "processing", "on-hold", "completed", "cancelled", "refunded", "failed"]
		status_counts = {}

		for status in statuses:
				response = requests.get(f"{orders_url}?status={status}", headers=headers)
				status_counts[status] = response.headers["X-WP-Total"]
				logger.info(f"Number of orders in '{status}' status: {status_counts[status]}")

		all_orders = []
		page = 1

		while True:
				response = requests.get(f"{orders_url}?per_page=100&page={page}", headers=headers)
				if response.json():
						orders = response.json()
						all_orders.extend(orders)
						logger.info(f"Read {len(orders)} orders from WooCommerce in 'processing' or 'pending' state (page {page})")
						page += 1
				else:
						break

		new_orders = [
				order for order in all_orders
				if (order["status"] == "processing" and order["id"] not in processed_orders)
				# Comment out the line below to stop processing pending orders
				# or (order["status"] == "pending" and order["id"] not in pending_orders)
		]
		logger.info(f"{len(new_orders)} orders have not been previously processed and will be processed now")

		for order in new_orders:
				logger.info(f"Processing order ID: {order['id']}")

				packing_slip = "<html><head><style>"
				packing_slip += "body { font-family: Arial, sans-serif; }"
				packing_slip += "h1 { color: #333; }"
				packing_slip += "h2 { color: #666; }"
				packing_slip += "table { border-collapse: collapse; width: 100%; }"
				packing_slip += "th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }"
				packing_slip += "th { background-color: #f2f2f2; }"
				packing_slip += "</style></head><body>"
				packing_slip += f"<h1>Order Details - Order ID: {order['id']}</h1>"
				packing_slip += "<h2>Customer Details:</h2>"
				packing_slip += f"<p>Name: {html.unescape(order['shipping']['first_name'])} {html.unescape(order['shipping']['last_name'])}</p>"
				packing_slip += f"<p>Shipping Address: {html.unescape(order['shipping']['address_1'])}, {html.unescape(order['shipping']['city'])}, {html.unescape(order['shipping']['state'])} {html.unescape(order['shipping']['postcode'])}, {html.unescape(order['shipping']['country'])}</p>"
				packing_slip += "<h2>Order Details:</h2>"
				order_date = datetime.strptime(order["date_created"], "%Y-%m-%dT%H:%M:%S")
				packing_slip += f"<p>Order Date: {order_date.strftime('%Y-%m-%d %I:%M %p')}</p>"
				packing_slip += f"<p>Payment Method: {html.unescape(order['payment_method_title'])}</p>"
				packing_slip += "<h2>Items:</h2>"
				packing_slip += "<table>"
				packing_slip += "<tr><th>Item</th><th>Quantity</th><th>Customizations</th></tr>"

				for idx, line_item in enumerate(order["line_items"], start=1):
						packing_slip += f"<tr><td>{html.unescape(line_item['name'])}</td><td>{line_item['quantity']}</td><td>"
						for meta in line_item["meta_data"]:
								if meta["display_key"] and meta["display_value"] and meta["display_key"] != "_wapf_meta":
										display_value = meta["display_value"]
										if "(+$" in display_value:
												display_value = display_value.split("(+$")[0].strip()
										packing_slip += f"{html.unescape(meta['display_key'])}: {html.unescape(display_value)}<br>"
						packing_slip += "</td></tr>"

				packing_slip += "</table>"

				if order["customer_note"]:
						packing_slip += f"<h2>Customer Note:</h2><p>{html.unescape(order['customer_note'])}</p>"

				packing_slip += "</body></html>"

				msg = MIMEMultipart()
				if order["status"] == "processing":
						msg["Subject"] = f"New Order - Order ID {order['id']}"
				# Comment out the line below to stop sending emails for pending orders
				# else:
				#     msg["Subject"] = f"Pending Order - Order ID {order['id']}"
				msg["From"] = smtp_username
				msg['To'] = recipient_emails

				text = MIMEText(packing_slip, 'html')
				msg.attach(text)

				try:
						with smtplib.SMTP(smtp_server, smtp_port) as server:
								server.starttls()
								server.login(smtp_username, smtp_password)
								server.send_message(msg)
								logger.info(f"Email sent for order ID {order['id']}")
				except smtplib.SMTPException as e:
						logger.error(f"Error sending email for order ID {order['id']}: {e}")

				print(packing_slip)

				if order["status"] == "processing":
						processed_orders.add(order['id'])
				# Comment out the line below to stop marking pending orders
				# else:
				#     pending_orders.add(order['id'])

		with open(processed_orders_file, 'w') as f:
				json.dump(list(processed_orders), f)
				logger.info(f"Saved {len(processed_orders)} processed orders to the JSON file")

		with open(pending_orders_file, 'w') as f:
				json.dump(list(pending_orders), f)
				logger.info(f"Saved {len(pending_orders)} pending orders to the JSON file")

		return all_orders
## order_statistics.json

{"24h": {"total_orders": 5, "total_revenue": 11634.41, "new_customers": 2, "avg_order_value": 2326.882}, "7d": {"total_orders": 15, "total_revenue": 41612.770000000004, "new_customers": 4, "avg_order_value": 2774.184666666667}, "30d": {"total_orders": 56, "total_revenue": 108511.79999999994, "new_customers": 9, "avg_order_value": 1937.7107142857133}}
## order_statistics.py

## order_statistics.py

import json
import logging
from datetime import datetime, timedelta

logger = logging.getLogger('my_logger')

def update_order_statistics(orders):
		logger.info(f"Updating order statistics for {len(orders)} orders")
		now = datetime.now()
		stats = {
				'24h': {'total_orders': 0, 'total_revenue': 0, 'new_customers': set()},
				'7d': {'total_orders': 0, 'total_revenue': 0, 'new_customers': set()},
				'30d': {'total_orders': 0, 'total_revenue': 0, 'new_customers': set()}
		}

		for order in orders:
				order_date = datetime.strptime(order['date_created'], "%Y-%m-%dT%H:%M:%S")
				customer_id = order['customer_id']
				total = float(order['total'])

				if now - order_date <= timedelta(hours=24):
						stats['24h']['total_orders'] += 1
						stats['24h']['total_revenue'] += total
						stats['24h']['new_customers'].add(customer_id)

				if now - order_date <= timedelta(days=7):
						stats['7d']['total_orders'] += 1
						stats['7d']['total_revenue'] += total
						stats['7d']['new_customers'].add(customer_id)

				if now - order_date <= timedelta(days=30):
						stats['30d']['total_orders'] += 1
						stats['30d']['total_revenue'] += total
						stats['30d']['new_customers'].add(customer_id)

		for period in stats:
				stats[period]['new_customers'] = len(stats[period]['new_customers'])
				stats[period]['avg_order_value'] = stats[period]['total_revenue'] / stats[period]['total_orders'] if stats[period]['total_orders'] > 0 else 0

		logger.info(f"Calculated statistics: {stats}")

		try:
				with open('order_statistics.json', 'w') as f:
						json.dump(stats, f)
				logger.info("Successfully wrote order statistics to file")
		except Exception as e:
				logger.error(f"Error writing order statistics to file: {str(e)}")

		logger.info("Finished updating order statistics")

def get_order_statistics():
		try:
				with open('order_statistics.json', 'r') as f:
						stats = json.load(f)
						logger.debug(f"Successfully read order statistics: {stats}")
						return stats
		except FileNotFoundError:
				logger.error("order_statistics.json file not found")
				return {}
		except json.JSONDecodeError:
				logger.error("Error decoding order_statistics.json")
				return {}
		except Exception as e:
				logger.error(f"Unexpected error reading order_statistics.json: {str(e)}")
				return {}

## main.py

## main.py

from flask import Flask, render_template, request, redirect, url_for, abort
from apscheduler.schedulers.background import BackgroundScheduler
import threading
import os
from functools import wraps
from dotenv import load_dotenv
import time
import json
import logging

# Import from both files
from order_processing import process_orders
from order_statistics import update_order_statistics, get_order_statistics

load_dotenv()

app = Flask(__name__)

# Use a secret token for authentication
SECRET_TOKEN = os.getenv('SECRET_TOKEN')
print(f"SECRET_TOKEN: {SECRET_TOKEN}")
# Global variable to control the background task
keep_running = True

# Configure logging
logger = logging.getLogger('my_logger')
logger.setLevel(logging.DEBUG)  # Change to DEBUG for more detailed logs
file_handler = logging.FileHandler('app.log')
file_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

# Also keep console handler for immediate feedback
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(formatter)
logger.addHandler(console_handler)

def background_task():
		global keep_running
		while keep_running:
				logger.info("Starting background task")
				all_orders = process_orders()
				update_order_statistics(all_orders)
				logger.info("Background task completed")
				time.sleep(300)  # Run every 5 minutes

def token_required(f):
		@wraps(f)
		def decorated_function(*args, **kwargs):
				token = request.args.get('token')
				logger.info(f"Received token: {token}")  # Debugging log
				if token and token == SECRET_TOKEN:
						return f(*args, **kwargs)
				else:
						logger.warning("Invalid token received")
						abort(401)
		return decorated_function

def get_processed_orders():
		try:
				with open('processed_orders.json', 'r') as f:
						orders = json.load(f)
						logger.debug(f"Loaded {len(orders)} processed orders")
						return orders
		except FileNotFoundError:
				logger.warning("processed_orders.json not found")
				return []
		except json.JSONDecodeError:
				logger.error("Error decoding processed_orders.json")
				return []

def get_log_content():
		try:
				with open('log.txt', 'r') as f:
						content = f.read()
						logger.debug("Log content loaded successfully")
						return content
		except FileNotFoundError:
				logger.warning("log.txt not found")
				return "No log file found."

@app.route('/')
@token_required
def home():
		logger.info("Home route accessed")
		processed_orders = get_processed_orders()
		log_content = get_log_content()
		order_statistics = get_order_statistics()
		logger.info(f"Rendering home page with order_statistics: {order_statistics}")
		return render_template('home.html', status=keep_running, processed_orders=processed_orders, log_content=log_content, order_statistics=order_statistics)

@app.route('/toggle', methods=['POST'])
@token_required
def toggle():
		global keep_running
		keep_running = not keep_running
		logger.info(f"Background task toggled. New state: {'running' if keep_running else 'stopped'}")
		if keep_running:
				thread = threading.Thread(target=background_task)
				thread.start()
		return redirect(url_for('home', token=SECRET_TOKEN))

if __name__ == '__main__':
		logger.info("Starting the application")
		scheduler = BackgroundScheduler()
		scheduler.add_job(background_task, 'interval', minutes=5)
		scheduler.start()
		logger.info("Scheduler started")
		app.run(host='0.0.0.0', port=8080)

